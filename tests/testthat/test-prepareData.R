testthat::test_that("function checkData works", {

  dats = data.table::data.table(data.frame(ID = rep(-1,10), X = 1:10, Y = 1:10, Batch = "B1"), Sample_type = rep("Calibration Standard", 10), SAMPLE_ID = rep("A1", 10), Injection_order = 1:10, Dilution = "Dilution")

  COLNAMES. = c(Feature_ID = "ID", Batch = "Batch", X = "X", Y = "Y", Sample_type = "Sample_type", Sample_ID = "SAMPLE_ID", Injection_order = "Injection_order", ColDilution = "Dilution")
  nCORE. = 1
  MIN_FEATURE. = 6
  TYPE. = "targeted"
  CALIBRANTS. = "Calibration Standard"
  BLANK. = "Blank"
  QC. = NULL
  SAMPLE. = NULL
  Y_SAMPLE. = NULL
  DILUTION_FACTOR. = 2
  NOISE. = NULL
  TRANSFORM. = TRUE
  TRANSFORM_X. = "log"
  INVERSE_X. = "exp"
  TRANSFORM_Y. = "log"
  INVERSE_Y. = "exp"
  FOD. = TRUE
  FOD_MODEL. = c("logistic", "linear", "quadratic")
  FOD_SDRES_MIN. = 1
  FOD_STDRES_MAX. = 2
  TRIMM. = TRUE
  SOD. = TRUE
  SOD_MODEL. = c("logistic", "linear", "quadratic")
  SOD_SDRES_MIN. = 1
  SOD_STDRES_MAX. = 2
  LR_SD_RES_FACTOR. = 2
  R2_MIN. = 0.9
  BATCH_HARMONIZATION. = TRUE
  CAL_CONC. = TRUE
  GET_LR_STATUS. = TRUE
  GET_OUTPUT. = TRUE
  IMG_OUTPUT_DIR. = "img"

  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    BLANK.,
                                    SAMPLE.,
                                    #Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    #DILUTION_FACTOR.,
                                    NOISE.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    #CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.,
                                    IMG_OUTPUT_DIR.
  )$ID, ptype = character(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    BLANK.,
                                    SAMPLE.,
                                    #Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    #DILUTION_FACTOR.,
                                    NOISE.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    #CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.,
                                    IMG_OUTPUT_DIR.
  )$Batch, ptype = character(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    BLANK.,
                                    SAMPLE.,
                                    #Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    #DILUTION_FACTOR.,
                                    NOISE.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    #CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.,
                                    IMG_OUTPUT_DIR.
  )$Class, ptype = character(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    BLANK.,
                                    SAMPLE.,
                                    #Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    #DILUTION_FACTOR.,
                                    NOISE.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    #CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.,
                                    IMG_OUTPUT_DIR.
  )$X, ptype = double(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    BLANK.,
                                    SAMPLE.,
                                    #Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    #DILUTION_FACTOR.,
                                    NOISE.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    #CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.,
                                    IMG_OUTPUT_DIR.
  )$Y, ptype = double(), size= 10)





  testthat::expect_error(checkData(dat =  dats|> dplyr::mutate(X = X*-1),
                                   MIN_FEATURE.,
                                   TYPE.,
                                   QC.,
                                   BLANK.,
                                   SAMPLE.,
                                   #Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   #DILUTION_FACTOR.,
                                   NOISE.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   #CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.,
                                   IMG_OUTPUT_DIR.
  ), regexp = "all values of 'column_X' and 'column_Y' need to be from type double and positive.")

  testthat::expect_error(checkData(dat =  dats|> dplyr::mutate(Y = Y*-1),
                                   MIN_FEATURE.,
                                   TYPE.,
                                   QC.,
                                   BLANK.,
                                   SAMPLE.,
                                   #Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   #DILUTION_FACTOR.,
                                   NOISE.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   #CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.,
                                   IMG_OUTPUT_DIR.
  ),regexp = "all values of 'column_X' and 'column_Y' need to be from type double and positive.")

  testthat::expect_error(checkData(dat =  dats,
                                   MIN_FEATURE = 2,
                                   TYPE.,
                                   QC.,
                                   BLANK.,
                                   SAMPLE.,
                                   #Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   #DILUTION_FACTOR.,
                                   NOISE.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   #CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.,
                                   IMG_OUTPUT_DIR.
  ), regexp = "Argument 'min_feature' needs to be greater or equal than 3")

  testthat::expect_error(checkData(dat =  dats,
                                   MIN_FEATURE.,
                                   TYPE = "test",
                                   QC.,
                                   BLANK.,
                                   SAMPLE.,
                                   #Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   #DILUTION_FACTOR.,
                                   NOISE.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   #CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.,
                                   IMG_OUTPUT_DIR.
  ), regexp = "Argument 'analysisType' need to be either 'untargeted' or 'targeted'")

  testthat::expect_error(checkData(dat =  dats,
                                   MIN_FEATURE.,
                                   TYPE.,
                                   QC = "test",
                                   BLANK.,
                                   SAMPLE.,
                                   #Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   #DILUTION_FACTOR.,
                                   NOISE.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   #CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.,
                                   IMG_OUTPUT_DIR.
  ), regexp = "Argument 'sampleType_QC' was not found in column 'column_sampleType'")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE = "test",
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'sampleType_sample' was not found in column 'column_sampleType'")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS = "test",
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'sampleType_serial' was not found in column 'column_sampleType'")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES = c(ID = "ID", Batch = NULL, X = " ", Y = "Y", Sample_type = "Sample_type", Sample_ID = "SAMPLE_ID"),
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "the provided names do not fit the colnames of the input data")


testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM = "test",
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'transform' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X = "bla",
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
                                 ))#, regexp = "Argument 'transform_X' and 'transform_Y' needs to be a String indicating a function, e.g. 'log10', disable with NULL")


testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X = "log",
                                 INVERSE_X = "log",
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
                                 ), regexp = "Argument 'inverse_X' must be the reverse function of Argument 'transform_X'")


testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y = "log",
                                 INVERSE_Y = 3,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'inverse_X' and 'inverse_Y' needs to be a String indicating a function, e.g. 'log10', disable with NULL")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y = "log",
                                 INVERSE_Y = NULL,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'inverse_Y' must be provided if Argument 'transform_Y' is provided")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = 3,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'first_outlier_detection' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = TRUE,
                                 FOD_MODEL = c("test"),
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "For the Argument 'FOD_model' only one or a combination of 'linear', 'logistic' or 'quadratic' are allowed.")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                # DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = TRUE,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN = 2.4,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                IMG_OUTPUT_DIR.
), regexp = "Argument 'FOD_sdres_min' and 'FOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = TRUE,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX = -6,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'FOD_sdres_min' and 'FOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM = NA,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                # CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                IMG_OUTPUT_DIR.
), regexp = "Argument 'trimming' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = 2,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'second_outlier_detection' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = TRUE,
                                 SOD_MODEL = NA,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "For the Argument SOD_model only one or a combination of 'linear', 'logistic', 'quadratic' are allowed.")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = TRUE,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN = -1,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'SOD_sdres_min' and 'SOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = TRUE,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX = "test",
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                # CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                IMG_OUTPUT_DIR.
), regexp = "Argument 'SOD_sdres_min' and 'SOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR = -5.6,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'LR_sd_res_factor' needs to be from type integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN = 20,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'R2_min' needs to be from type double and in the range between 0 and 1")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION = NA,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'Batch_harmonization' needs to be from type logical")


testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                # Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS = "test",
                                 nCORE.,
                                 GET_OUTPUT.,
                                IMG_OUTPUT_DIR.
), regexp = "Argument 'get_linearity_status_samples' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE = -3,
                                 GET_OUTPUT.,
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'nCore' needs to be positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 BLANK.,
                                 SAMPLE.,
                                 #Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 #DILUTION_FACTOR.,
                                 NOISE.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 #CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT = "test",
                                 IMG_OUTPUT_DIR.
), regexp = "Argument 'get_output' needs to be from type logical")


})







testthat::test_that("function prepareData works", {

  dats = data.table::data.table(data.frame(ID = rep(-1,10), X = 1:10, Y = 1:10, Batch = "B1"), Sample_type = rep("Calibration Standard", 10), SAMPLE_ID = rep("A1", 10), Injection_order = 1:10, Dilution = 1:10)

  COLNAMES. = c(Feature_ID = "ID", Batch = "Batch", X = "X", Y = "Y", Sample_type = "Sample_type", Sample_ID = "SAMPLE_ID", Injection_order = "Injection_order", ColDilution = "Dilution")
  nCORE. = 1
  MIN_FEATURE. = 6
  TYPE. = "targeted"
  CALIBRANTS. = "Calibration Standard"
  BLANK. = "Blank"
  QC. = NULL
  SAMPLE. = NULL
  Y_SAMPLE. = NULL
  DILUTION_FACTOR. = 2
  NOISE. = NULL
  TRANSFORM. = TRUE
  TRANSFORM_X. = "log"
  INVERSE_X. = "exp"
  TRANSFORM_Y. = "log"
  INVERSE_Y. = "exp"
  FOD. = TRUE
  FOD_MODEL. = c("logistic", "linear", "quadratic")
  FOD_SDRES_MIN. = 1
  FOD_STDRES_MAX. = 2
  TRIMM. = TRUE
  SOD. = TRUE
  SOD_MODEL. = c("logistic", "linear", "quadratic")
  SOD_SDRES_MIN. = 1
  SOD_STDRES_MAX. = 2
  LR_SD_RES_FACTOR. = 2
  R2_MIN. = 0.9
  BATCH_HARMONIZATION. = TRUE
  CAL_CONC. = TRUE
  GET_LR_STATUS. = TRUE
  GET_OUTPUT. = TRUE
  IMG_OUTPUT_DIR. = "img"

  data <- checkData(dat = dats,
            MIN_FEATURE.,
            TYPE.,
            QC.,
            BLANK.,
            SAMPLE.,
            #Y_SAMPLE.,
            CALIBRANTS.,
            COLNAMES.,
            #DILUTION_FACTOR.,
            NOISE.,
            TRANSFORM.,
            TRANSFORM_X.,
            INVERSE_X.,
            TRANSFORM_Y.,
            INVERSE_Y.,
            FOD.,
            FOD_MODEL.,
            FOD_SDRES_MIN.,
            FOD_STDRES_MAX.,
            TRIMM.,
            SOD.,
            SOD_MODEL.,
            SOD_SDRES_MIN.,
            SOD_STDRES_MAX.,
            LR_SD_RES_FACTOR.,
            R2_MIN.,
            BATCH_HARMONIZATION.,
            #CAL_CONC.,
            GET_LR_STATUS.,
            nCORE.,
            GET_OUTPUT.,
            IMG_OUTPUT_DIR.
  )

  testthat::expect_equal(
    dim(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.))[1],
    10)

  testthat::expect_equal(
    dim(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.))[2],
    17)

  testthat::expect_equal(
    unique(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$pch),
    19)

  testthat::expect_equal(
    unique(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$color),
    "black")

  testthat::expect_equal(
    prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$X_trans[2],
    get(TRANSFORM_X.)(data$X[2]*3))

  testthat::expect_equal(
    prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$Y_trans[9],
    get(TRANSFORM_Y.)(data$Y[9]))

  testthat::expect_error(prepareData(dat = data[,-1], TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)
    , regexp = "data need to have 11 columns, please use funtion 'checkData' before to check all necessary input arguments")



})

