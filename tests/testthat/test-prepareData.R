testthat::test_that("function checkData works", {

  dats = data.table::data.table(data.frame(ID = rep(-1,10), X = 1:10, Y = 1:10), Sample_type = rep("Calibration Standard", 10), SAMPLE_ID = rep("A1", 10))

  COLNAMES. = c(ID = "ID", Batch = NULL, X = "X", Y = "Y", Sample_type = "Sample_type", Sample_ID = "SAMPLE_ID")
  nCORE. = 1
  MIN_FEATURE. = 6
  TYPE. = "targeted"
  CALIBRANTS. = "Calibration Standard"
  QC. = NULL
  SAMPLE. = NULL
  Y_SAMPLE. = NULL
  DILUTION_FACTOR. = 2
  TRANSFORM. = TRUE
  TRANSFORM_X. = "log"
  INVERSE_X. = "exp"
  TRANSFORM_Y. = "log"
  INVERSE_Y. = "exp"
  FOD. = TRUE
  FOD_MODEL. = c("logistic", "linear", "quadratic")
  FOD_SDRES_MIN. = 1
  FOD_STDRES_MAX. = 2
  TRIMM. = TRUE
  SOD. = TRUE
  SOD_MODEL. = c("logistic", "linear", "quadratic")
  SOD_SDRES_MIN. = 1
  SOD_STDRES_MAX. = 2
  LR_SD_RES_FACTOR. = 2
  R2_MIN. = 0.9
  BATCH_HARMONIZATION. = TRUE
  CAL_CONC. = TRUE
  GET_LR_STATUS. = TRUE
  GET_OUTPUT. = TRUE

  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    SAMPLE.,
                                    Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    DILUTION_FACTOR.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.
  )$ID, ptype = character(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    SAMPLE.,
                                    Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    DILUTION_FACTOR.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.
  )$Batch, ptype = character(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    SAMPLE.,
                                    Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    DILUTION_FACTOR.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.
  )$Class, ptype = character(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    SAMPLE.,
                                    Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    DILUTION_FACTOR.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.
  )$X, ptype = double(), size= 10)
  testthat::expect_vector(checkData(dat = dats,
                                    MIN_FEATURE.,
                                    TYPE.,
                                    QC.,
                                    SAMPLE.,
                                    Y_SAMPLE.,
                                    CALIBRANTS.,
                                    COLNAMES.,
                                    DILUTION_FACTOR.,
                                    TRANSFORM.,
                                    TRANSFORM_X.,
                                    INVERSE_X.,
                                    TRANSFORM_Y.,
                                    INVERSE_Y.,
                                    FOD.,
                                    FOD_MODEL.,
                                    FOD_SDRES_MIN.,
                                    FOD_STDRES_MAX.,
                                    TRIMM.,
                                    SOD.,
                                    SOD_MODEL.,
                                    SOD_SDRES_MIN.,
                                    SOD_STDRES_MAX.,
                                    LR_SD_RES_FACTOR.,
                                    R2_MIN.,
                                    BATCH_HARMONIZATION.,
                                    CAL_CONC.,
                                    GET_LR_STATUS.,
                                    nCORE.,
                                    GET_OUTPUT.
  )$Y, ptype = double(), size= 10)





  testthat::expect_error(checkData(dat =  dats|> dplyr::mutate(X = X*-1),
                                   MIN_FEATURE.,
                                   TYPE.,
                                   QC.,
                                   SAMPLE.,
                                   Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   DILUTION_FACTOR.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.
  ), regexp = "all values of 'column_X' and 'column_Y' need to be from type double and positive.")

  testthat::expect_error(checkData(dat =  dats|> dplyr::mutate(Y = Y*-1),
                                   MIN_FEATURE.,
                                   TYPE.,
                                   QC.,
                                   SAMPLE.,
                                   Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   DILUTION_FACTOR.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.
  ),regexp = "all values of 'column_X' and 'column_Y' need to be from type double and positive.")

  testthat::expect_error(checkData(dat =  dats,
                                   MIN_FEATURE = 2,
                                   TYPE.,
                                   QC.,
                                   SAMPLE.,
                                   Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   DILUTION_FACTOR.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.
  ), regexp = "Argument 'min_feature' needs to be greater or equal than 3")

  testthat::expect_error(checkData(dat =  dats,
                                   MIN_FEATURE.,
                                   TYPE = "test",
                                   QC.,
                                   SAMPLE.,
                                   Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   DILUTION_FACTOR.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.
  ), regexp = "Argument 'analysis_type' need to be either 'untargeted' or 'targeted'")

  testthat::expect_error(checkData(dat =  dats,
                                   MIN_FEATURE.,
                                   TYPE.,
                                   QC = "test",
                                   SAMPLE.,
                                   Y_SAMPLE.,
                                   CALIBRANTS.,
                                   COLNAMES.,
                                   DILUTION_FACTOR.,
                                   TRANSFORM.,
                                   TRANSFORM_X.,
                                   INVERSE_X.,
                                   TRANSFORM_Y.,
                                   INVERSE_Y.,
                                   FOD.,
                                   FOD_MODEL.,
                                   FOD_SDRES_MIN.,
                                   FOD_STDRES_MAX.,
                                   TRIMM.,
                                   SOD.,
                                   SOD_MODEL.,
                                   SOD_SDRES_MIN.,
                                   SOD_STDRES_MAX.,
                                   LR_SD_RES_FACTOR.,
                                   R2_MIN.,
                                   BATCH_HARMONIZATION.,
                                   CAL_CONC.,
                                   GET_LR_STATUS.,
                                   nCORE.,
                                   GET_OUTPUT.
  ), regexp = "Argument 'sample_type_QC' was not found in column 'column_sample_type'")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE = "test",
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'sample_type_sample' was not found in column 'column_sample_type'")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS = "test",
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'sample_type_serial' was not found in column 'column_sample_type'")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES = c(ID = "ID", Batch = NULL, X = " ", Y = "Y", Sample_type = "Sample_type", Sample_ID = "SAMPLE_ID"),
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "missing columns")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR = "a",
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'dilution_factor' needs to be from type numeric.")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE = "Calibration Standard",
                                 Y_SAMPLE = 2,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Column 'column_Y_sample' was not found in input data.")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM = "test",
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'transform' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X = "bla",
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
                                 ), regexp = "Argument 'transform_X' and 'transform_Y' needs to be a String indicating a function, e.g. 'log10', disable with NULL")


testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X = "log",
                                 INVERSE_X = "log",
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
                                 ), regexp = "Argument 'inverse_X' must be the reverse function of Argument 'transform_X'")


testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y = "log",
                                 INVERSE_Y = 3,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'inverse_X' and 'inverse_Y' needs to be a String indicating a function, e.g. 'log10', disable with NULL")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM = TRUE,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y = "log",
                                 INVERSE_Y = NULL,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'inverse_Y' must be provided if Argument 'transform_Y' is provided")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = 3,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'first_outlier_detection' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = TRUE,
                                 FOD_MODEL = c("test"),
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "For the Argument 'FOD_model' only one or a combination of 'linear', 'logistic' or 'quadratic' are allowed.")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = TRUE,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN = 2.4,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'FOD_sdres_min' and 'FOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD = TRUE,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX = -6,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'FOD_sdres_min' and 'FOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM = NA,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'trimming' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = 2,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'second_outlier_detection' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = TRUE,
                                 SOD_MODEL = NA,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "For the Argument SOD_model only one or a combination of 'linear', 'logistic', 'quadratic' are allowed.")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = TRUE,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN = -1,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'SOD_sdres_min' and 'SOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD = TRUE,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX = "test",
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'SOD_sdres_min' and 'SOD_stdres_max' need to be from type Integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR = -5.6,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'LR_sd_res_factor' needs to be from type integer and positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN = 20,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'R2_min' needs to be from type double and in the range between 0 and 1")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION = NA,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'Batch_harmonization' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC = "test",
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'calculate_concentration' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS = "test",
                                 nCORE.,
                                 GET_OUTPUT.
), regexp = "Argument 'get_linearity_status_samples' needs to be from type logical")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE = -3,
                                 GET_OUTPUT.
), regexp = "Argument 'nCore' needs to be positive")

testthat::expect_error(checkData(dat =  dats,
                                 MIN_FEATURE.,
                                 TYPE.,
                                 QC.,
                                 SAMPLE.,
                                 Y_SAMPLE.,
                                 CALIBRANTS.,
                                 COLNAMES.,
                                 DILUTION_FACTOR.,
                                 TRANSFORM.,
                                 TRANSFORM_X.,
                                 INVERSE_X.,
                                 TRANSFORM_Y.,
                                 INVERSE_Y.,
                                 FOD.,
                                 FOD_MODEL.,
                                 FOD_SDRES_MIN.,
                                 FOD_STDRES_MAX.,
                                 TRIMM.,
                                 SOD.,
                                 SOD_MODEL.,
                                 SOD_SDRES_MIN.,
                                 SOD_STDRES_MAX.,
                                 LR_SD_RES_FACTOR.,
                                 R2_MIN.,
                                 BATCH_HARMONIZATION.,
                                 CAL_CONC.,
                                 GET_LR_STATUS.,
                                 nCORE.,
                                 GET_OUTPUT = "test"
), regexp = "Argument 'get_output' needs to be from type logical")


})







testthat::test_that("function prepareData works", {

  dats = data.table::data.table(data.frame(ID = rep(-1,10), "Dilution" = 1:10, Y = 1:10), Sample_type = rep("Calibration Standard", 10), SAMPLE_ID = rep("A1", 10))

  COLNAMES. = c(ID = "ID", Batch = NULL, X = "Dilution", Y = "Y", Sample_type = "Sample_type", Sample_ID = "SAMPLE_ID")
  nCORE. = 1
  MIN_FEATURE. = 6
  TYPE. = "targeted"
  CALIBRANTS. = "Calibration Standard"
  QC. = NULL
  SAMPLE. = NULL
  Y_SAMPLE. = NULL
  DILUTION_FACTOR. = 2
  TRANSFORM. = TRUE
  TRANSFORM_X. = "log"
  INVERSE_X. = "exp"
  TRANSFORM_Y. = "log"
  INVERSE_Y. = "exp"
  FOD. = TRUE
  FOD_MODEL. = c("logistic", "linear", "quadratic")
  FOD_SDRES_MIN. = 1
  FOD_STDRES_MAX. = 2
  TRIMM. = TRUE
  SOD. = TRUE
  SOD_MODEL. = c("logistic", "linear", "quadratic")
  SOD_SDRES_MIN. = 1
  SOD_STDRES_MAX. = 2
  LR_SD_RES_FACTOR. = 2
  R2_MIN. = 0.9
  BATCH_HARMONIZATION. = TRUE
  CAL_CONC. = TRUE
  GET_LR_STATUS. = TRUE
  GET_OUTPUT. = TRUE

  data <- checkData(dat = dats,
            MIN_FEATURE.,
            TYPE.,
            QC.,
            SAMPLE.,
            Y_SAMPLE.,
            CALIBRANTS.,
            COLNAMES.,
            DILUTION_FACTOR.,
            TRANSFORM.,
            TRANSFORM_X.,
            INVERSE_X.,
            TRANSFORM_Y.,
            INVERSE_Y.,
            FOD.,
            FOD_MODEL.,
            FOD_SDRES_MIN.,
            FOD_STDRES_MAX.,
            TRIMM.,
            SOD.,
            SOD_MODEL.,
            SOD_SDRES_MIN.,
            SOD_STDRES_MAX.,
            LR_SD_RES_FACTOR.,
            R2_MIN.,
            BATCH_HARMONIZATION.,
            CAL_CONC.,
            GET_LR_STATUS.,
            nCORE.,
            GET_OUTPUT.
  )

  testthat::expect_equal(
    dim(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.))[1],
    10)

  testthat::expect_equal(
    dim(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.))[2],
    16)

  testthat::expect_equal(
    unique(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$pch),
    19)

  testthat::expect_equal(
    unique(prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$color),
    "black")

  testthat::expect_equal(
    prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$X_trans[2],
    get(TRANSFORM_X.)(data$Dilution[2]))

  testthat::expect_equal(
    prepareData(dat = data, TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)$Y_trans[9],
    get(TRANSFORM_Y.)(data$Y[9]))

  testthat::expect_error(prepareData(dat = data[,-1], TRANSFORM., TRANSFORM_X., TRANSFORM_Y., DILUTION_FACTOR., COLNAMES., TYPE.)
    , regexp = "data need to have 9 columns, please use funtion 'checkData' before to check all necessary input arguments")



})

